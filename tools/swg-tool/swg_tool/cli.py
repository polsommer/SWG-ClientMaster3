"""Command-line entry point for the SWG God Client workflow automation tooling."""

from __future__ import annotations

import argparse
import json
import sys
import tempfile
from pathlib import Path
from typing import Iterable, Optional

from . import __version__
from .manifest import ManifestValidator
from .navmesh import NavMeshGenerator
from .publisher import Publisher, PublishError
from .response import ResponseFileBuilder, ResponseFileBuilderError
from .rspconfig import (
    TreeFileRspConfigBuilder,
    TreeFileRspConfigBuilderError,
)
from .treebuilder import TreeFileBuilder, TreeFileBuilderError


def _path(value: str) -> Path:
    path = Path(value).expanduser().resolve()
    return path


def _existing_file(value: str) -> Path:
    path = _path(value)
    if not path.is_file():
        raise argparse.ArgumentTypeError(f"File not found: {path}")
    return path


def _existing_directory(value: str) -> Path:
    path = _path(value)
    if not path.is_dir():
        raise argparse.ArgumentTypeError(f"Directory not found: {path}")
    return path


def _existing_path(value: str) -> Path:
    path = _path(value)
    if not path.exists():
        raise argparse.ArgumentTypeError(f"Path not found: {path}")
    return path


def _ensure_directory(path: Path) -> Path:
    path.mkdir(parents=True, exist_ok=True)
    return path


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Tools for modern SWG God Client workflows")
    parser.add_argument("--version", action="version", version=f"swg-tool {__version__}")

    subparsers = parser.add_subparsers(dest="command", required=True)

    validate_parser = subparsers.add_parser(
        "validate", help="Validate plugin or content pack manifests"
    )
    validate_parser.add_argument(
        "manifests",
        nargs="+",
        type=_existing_file,
        help="Path(s) to manifest JSON files",
    )
    validate_parser.set_defaults(func=_run_validate)

    navmesh_parser = subparsers.add_parser(
        "generate-navmesh", help="Generate a prototype navmesh JSON from a heightmap"
    )
    navmesh_parser.add_argument(
        "--terrain",
        required=True,
        type=_existing_file,
        help="Input heightmap file (plain text grid of elevations)",
    )
    navmesh_parser.add_argument(
        "--output",
        required=True,
        type=_path,
        help="Destination JSON file for the generated navmesh",
    )
    navmesh_parser.add_argument(
        "--walkable-threshold",
        type=float,
        default=15.0,
        help="Maximum slope (degrees) considered walkable",
    )
    navmesh_parser.set_defaults(func=_run_generate_navmesh)

    publish_parser = subparsers.add_parser(
        "publish", help="Create a versioned publish bundle"
    )
    publish_parser.add_argument(
        "--content",
        required=True,
        type=_existing_directory,
        help="Directory containing validated content to publish",
    )
    publish_parser.add_argument(
        "--destination",
        required=True,
        type=_path,
        help="Directory where the publish bundle should be written",
    )
    publish_parser.add_argument(
        "--manifest",
        type=_existing_file,
        help="Optional manifest JSON describing the bundle",
    )
    publish_parser.add_argument(
        "--label",
        type=str,
        default="snapshot",
        help="Human-readable label for the release",
    )
    publish_parser.set_defaults(func=_run_publish)

    config_parser = subparsers.add_parser(
        "generate-rsp-config",
        help="Create a configuration file for TreeFileRspBuilder_r",
    )
    config_parser.add_argument(
        "--output",
        type=_path,
        default=Path("TreeFileRspBuilder.cfg"),
        help="Destination for the generated configuration file",
    )
    config_parser.add_argument(
        "--entry",
        dest="entries",
        metavar="COMMENT=PATH",
        action="append",
        required=True,
        help=(
            "searchPath entry to include. Prefix the value with an optional "
            "comment followed by '=' (for example, --entry "
            "'Root data=C:/swg/live/data')."
        ),
    )
    config_parser.add_argument(
        "--allow-missing",
        action="store_true",
        help="Allow searchPath entries that do not currently exist",
    )
    config_parser.add_argument(
        "--no-header",
        action="store_true",
        help="Omit the autogenerated header comments",
    )
    config_parser.set_defaults(func=_run_generate_rsp_config)

    response_parser = subparsers.add_parser(
        "generate-response",
        help="Create a TreeFileBuilder response (.rsp) file from source paths",
    )
    response_parser.add_argument(
        "--destination",
        required=True,
        type=_path,
        help="File path where the generated response should be written",
    )
    response_parser.add_argument(
        "--source",
        dest="sources",
        action="append",
        type=_existing_path,
        help=(
            "File or directory to include in the generated response file. "
            "Provide multiple times to include additional paths."
        ),
    )
    response_parser.add_argument(
        "--entry-root",
        type=_existing_directory,
        help=(
            "Optional root directory used to compute tree entry names when generating a "
            "response file. Defaults to the common ancestor of all --source paths."
        ),
    )
    response_parser.add_argument(
        "--allow-overrides",
        action="store_true",
        help=(
            "Allow later --source paths to override earlier entries when duplicate tree "
            "paths are encountered."
        ),
    )
    response_parser.set_defaults(func=_run_generate_response)

    tree_parser = subparsers.add_parser(
        "build-tree", help="Build a .tre/.tres archive using TreeFileBuilder"
    )
    tree_parser.add_argument(
        "--response",
        type=_path,
        help=(
            "Response (.rsp) file describing the tree contents. When used with --source, "
            "the response file will be generated at this location."
        ),
    )
    tree_parser.add_argument(
        "--source",
        dest="sources",
        action="append",
        type=_existing_path,
        help=(
            "File or directory to include when generating a response file. "
            "Provide multiple times to include additional paths."
        ),
    )
    tree_parser.add_argument(
        "--entry-root",
        type=_existing_directory,
        help=(
            "Optional root directory used to compute tree entry names when generating a "
            "response file. Defaults to the common ancestor of all --source paths."
        ),
    )
    tree_parser.add_argument(
        "--allow-overrides",
        action="store_true",
        help=(
            "Allow later --source paths to override earlier entries when duplicate tree "
            "paths are encountered."
        ),
    )
    tree_parser.add_argument(
        "--output",
        required=True,
        type=_path,
        help="Destination tree archive (.tre or .tres)",
    )
    tree_parser.add_argument(
        "--builder",
        type=_path,
        help="Optional path to the TreeFileBuilder executable",
    )
    tree_parser.add_argument(
        "--no-toc-compression",
        action="store_true",
        help="Disable compression of the tree table of contents",
    )
    tree_parser.add_argument(
        "--no-file-compression",
        action="store_true",
        help="Disable compression of file payloads",
    )
    tree_parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Perform a dry run without writing the archive",
    )
    tree_parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress verbose TreeFileBuilder output",
    )
    tree_parser.add_argument(
        "--encrypt",
        action="store_true",
        help="Force encryption to produce a .tres archive",
    )
    tree_parser.add_argument(
        "--no-encrypt",
        action="store_true",
        help="Disable encryption even if the response requests it",
    )
    tree_parser.add_argument(
        "--passphrase",
        help="Encryption passphrase for .tres archives",
    )
    tree_parser.set_defaults(func=_run_build_tree)

    return parser


def _run_validate(args: argparse.Namespace) -> None:
    validator = ManifestValidator()
    errors = []
    for manifest in args.manifests:
        errors.extend(validator.validate_manifest(manifest))

    if errors:
        for error in errors:
            print(f"[ERROR] {error}")
        raise SystemExit(1)

    print(f"Validated {len(args.manifests)} manifest(s) successfully.")


def _run_generate_navmesh(args: argparse.Namespace) -> None:
    generator = NavMeshGenerator(walkable_threshold=args.walkable_threshold)
    navmesh = generator.generate_from_heightmap(args.terrain)
    _ensure_directory(args.output.parent)
    args.output.write_text(json.dumps(navmesh, indent=2))
    print(f"Navmesh written to {args.output}")


def _run_publish(args: argparse.Namespace) -> None:
    publisher = Publisher()
    destination = _ensure_directory(args.destination)
    manifest: Optional[dict] = None
    if args.manifest:
        manifest = json.loads(args.manifest.read_text())

    try:
        result = publisher.publish(args.content, destination, manifest=manifest, label=args.label)
    except PublishError as exc:
        print(f"[ERROR] {exc}")
        raise SystemExit(1) from exc

    print(
        "Published bundle",
        result.version,
        "->",
        result.output_directory,
    )


def _parse_config_entry(value: str) -> tuple[Optional[str], Path]:
    if "=" in value:
        comment, raw_path = value.split("=", 1)
        comment = comment.strip() or None
    else:
        comment = None
        raw_path = value

    path = Path(raw_path.strip()).expanduser()
    return comment, path


def _run_generate_rsp_config(args: argparse.Namespace) -> None:
    builder = TreeFileRspConfigBuilder(
        allow_missing_paths=args.allow_missing,
        include_header=not args.no_header,
    )

    parsed_entries = [_parse_config_entry(value) for value in args.entries]

    try:
        output_path = builder.write(args.output, parsed_entries)
    except TreeFileRspConfigBuilderError as exc:
        print(f"[ERROR] {exc}")
        raise SystemExit(1) from exc

    noun = "entry" if len(parsed_entries) == 1 else "entries"
    print(
        f"Configuration written to {output_path} with {len(parsed_entries)} {noun}."
    )


def _run_generate_response(args: argparse.Namespace) -> None:
    if not args.sources:
        print("[ERROR] At least one --source path must be provided.")
        raise SystemExit(2)

    builder_kwargs = {}
    if args.entry_root:
        builder_kwargs["entry_root"] = args.entry_root
    if args.allow_overrides:
        builder_kwargs["allow_overrides"] = True

    try:
        builder = ResponseFileBuilder(**builder_kwargs)
        result = builder.write(destination=args.destination, sources=args.sources)
    except ResponseFileBuilderError as exc:
        print(f"[ERROR] {exc}")
        raise SystemExit(1) from exc

    entry_count = len(result.entries)
    noun = "entry" if entry_count == 1 else "entries"
    print(
        f"Response file written to {result.path} with {entry_count} {noun}."
    )


def _run_build_tree(args: argparse.Namespace) -> None:
    builder = TreeFileBuilder(executable=args.builder)
    response_path = args.response
    temp_dir: Optional[tempfile.TemporaryDirectory] = None

    try:
        if args.sources:
            response_builder_kwargs = {}
            if args.entry_root:
                response_builder_kwargs["entry_root"] = args.entry_root
            if args.allow_overrides:
                response_builder_kwargs["allow_overrides"] = True

            response_builder = ResponseFileBuilder(**response_builder_kwargs)

            if response_path is None:
                temp_dir = tempfile.TemporaryDirectory()
                response_path = Path(temp_dir.name) / "tree_contents.rsp"

            response_result = response_builder.write(
                destination=response_path, sources=args.sources
            )
            response_path = response_result.path

            entry_count = len(response_result.entries)
            noun = "entry" if entry_count == 1 else "entries"
            print(
                f"Generated response file with {entry_count} {noun} at {response_result.path}"
            )
        elif response_path is None:
            print("[ERROR] --response is required when no --source paths are provided.")
            raise SystemExit(2)

        stdout_callback = None
        stderr_callback = None
        suppress_output = bool(args.quiet)
        if not suppress_output:
            def _forward_stdout(chunk: str) -> None:
                sys.stdout.write(chunk)
                sys.stdout.flush()

            def _forward_stderr(chunk: str) -> None:
                sys.stderr.write(chunk)
                sys.stderr.flush()

            stdout_callback = _forward_stdout
            stderr_callback = _forward_stderr

        result = builder.build(
            response_file=response_path,
            output_file=args.output,
            no_toc_compression=args.no_toc_compression,
            no_file_compression=args.no_file_compression,
            dry_run=args.dry_run,
            quiet=args.quiet,
            force_encrypt=args.encrypt,
            disable_encrypt=args.no_encrypt,
            passphrase=args.passphrase,
            stdout_callback=stdout_callback,
            stderr_callback=stderr_callback,
        )
    except ResponseFileBuilderError as exc:
        print(f"[ERROR] {exc}")
        raise SystemExit(1) from exc
    except TreeFileBuilderError as exc:
        print(f"[ERROR] {exc}")
        if exc.result and not suppress_output:
            if exc.result.stdout and stdout_callback is None:
                print(exc.result.stdout)
            if exc.result.stderr and stderr_callback is None:
                print(exc.result.stderr)
        raise SystemExit(1) from exc
    finally:
        if temp_dir:
            temp_dir.cleanup()

    if not suppress_output:
        if result.stdout and stdout_callback is None:
            print(result.stdout)
        if result.stderr and stderr_callback is None:
            print(result.stderr)

    print(f"Tree file written to {result.output}")


def main(argv: Optional[Iterable[str]] = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)


__all__ = ["build_parser", "main"]
